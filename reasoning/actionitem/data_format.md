# Readable format
### Refined Data Sample

| Test Target                             | Target Object  | Input Data                 | Expected Output | Clang-repl Test                                                             |
|-----------------------------------------|-------------------------| -------------------------- | --------------- | --------------------------------------------------------------------------- |
| int add(int a, int b)<br/>{return a+b;} | Add two variables       | int a = 1;</br> int b = 2; | %<< result 3    | int a = 1;</br>int b = 2;</br>int result = add(a, b);</br>%<< result;</br>3 |
|                                         |                         |                            |                 |                                                                             |

### Nutanix/CPP-UNITTEST-BENCH
can be used for complete sample.
Code => Test Target
Unit Test - (Ground Truth) =Refine=> Input Data | Expected Output | Clang-repl Test
=generated=> Target Object  
#### raw data
```json
{
  "ID": 0,
  "Language": "cpp",
  "Repository Name": "google/cel-cpp",
  "File Name": "kind",
  "File Path in Repository": "common/kind.cc",
  "File Path for Unit Test": "common/kind_test.cc",
  "Code": "#ifndef THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#define THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#include \"common/kind.h\"        \n#include \"common/type_kind.h\"   \n#include \"common/value_kind.h\"  \n#endif  \n#include \"common/kind.h\"\n#include \"absl/strings/string_view.h\"\nnamespace cel {\nabsl::string_view KindToString(Kind kind) {\n  switch (kind) {\n    case Kind::kNullType:\n      return \"null_type\";\n    case Kind::kDyn:\n      return \"dyn\";\n    case Kind::kAny:\n      return \"any\";\n    case Kind::kType:\n      return \"type\";\n    case Kind::kTypeParam:\n      return \"type_param\";\n    case Kind::kFunction:\n      return \"function\";\n    case Kind::kBool:\n      return \"bool\";\n    case Kind::kInt:\n      return \"int\";\n    case Kind::kUint:\n      return \"uint\";\n    case Kind::kDouble:\n      return \"double\";\n    case Kind::kString:\n      return \"string\";\n    case Kind::kBytes:\n      return \"bytes\";\n    case Kind::kDuration:\n      return \"duration\";\n    case Kind::kTimestamp:\n      return \"timestamp\";\n    case Kind::kList:\n      return \"list\";\n    case Kind::kMap:\n      return \"map\";\n    case Kind::kStruct:\n      return \"struct\";\n    case Kind::kUnknown:\n      return \"*unknown*\";\n    case Kind::kOpaque:\n      return \"*opaque*\";\n    case Kind::kBoolWrapper:\n      return \"google.protobuf.BoolValue\";\n    case Kind::kIntWrapper:\n      return \"google.protobuf.Int64Value\";\n    case Kind::kUintWrapper:\n      return \"google.protobuf.UInt64Value\";\n    case Kind::kDoubleWrapper:\n      return \"google.protobuf.DoubleValue\";\n    case Kind::kStringWrapper:\n      return \"google.protobuf.StringValue\";\n    case Kind::kBytesWrapper:\n      return \"google.protobuf.BytesValue\";\n    default:\n      return \"*error*\";\n  }\n}\n}",
  "Unit Test - (Ground Truth)": "#include \"common/kind.h\"\n#include <limits>\n#include <type_traits>\n#include \"common/type_kind.h\"\n#include \"common/value_kind.h\"\n#include \"internal/testing.h\"\n\nnamespace cel {\nnamespace {\nstatic_assert(\n  std::is_same_v<std::underlying_type_t<TypeKind>, std::underlying_type_t<ValueKind>>,\n  \"TypeKind and ValueKind must have the same underlying type\"\n);\n\nTEST(Kind, ToString) {\n  EXPECT_EQ(KindToString(Kind::kError), \"*error*\");\n  EXPECT_EQ(KindToString(Kind::kNullType), \"null_type\");\n  EXPECT_EQ(KindToString(Kind::kDyn), \"dyn\");\n  EXPECT_EQ(KindToString(Kind::kAny), \"any\");\n  EXPECT_EQ(KindToString(Kind::kType), \"type\");\n  EXPECT_EQ(KindToString(Kind::kBool), \"bool\");\n  EXPECT_EQ(KindToString(Kind::kInt), \"int\");\n  EXPECT_EQ(KindToString(Kind::kUint), \"uint\");\n  EXPECT_EQ(KindToString(Kind::kDouble), \"double\");\n  EXPECT_EQ(KindToString(Kind::kString), \"string\");\n  EXPECT_EQ(KindToString(Kind::kBytes), \"bytes\");\n  EXPECT_EQ(KindToString(Kind::kDuration), \"duration\");\n  EXPECT_EQ(KindToString(Kind::kTimestamp), \"timestamp\");\n  EXPECT_EQ(KindToString(Kind::kList), \"list\");\n  EXPECT_EQ(KindToString(Kind::kMap), \"map\");\n  EXPECT_EQ(KindToString(Kind::kStruct), \"struct\");\n  EXPECT_EQ(KindToString(Kind::kUnknown), \"*unknown*\");\n  EXPECT_EQ(KindToString(Kind::kOpaque), \"*opaque*\");\n  EXPECT_EQ(KindToString(Kind::kBoolWrapper), \"google.protobuf.BoolValue\");\n  EXPECT_EQ(KindToString(Kind::kIntWrapper), \"google.protobuf.Int64Value\");\n  EXPECT_EQ(KindToString(Kind::kUintWrapper), \"google.protobuf.UInt64Value\");\n  EXPECT_EQ(KindToString(Kind::kDoubleWrapper), \"google.protobuf.DoubleValue\");\n  EXPECT_EQ(KindToString(Kind::kStringWrapper), \"google.protobuf.StringValue\");\n  EXPECT_EQ(KindToString(Kind::kBytesWrapper), \"google.protobuf.BytesValue\");\n  EXPECT_EQ(KindToString(static_cast<Kind>(std::numeric_limits<int>::max())), \"*error*\");\n}\n\nTEST(Kind, TypeKindRoundtrip) {\n  EXPECT_EQ(TypeKindToKind(KindToTypeKind(Kind::kBool)), Kind::kBool);\n}\n\nTEST(Kind, ValueKindRoundtrip) {\n  EXPECT_EQ(ValueKindToKind(KindToValueKind(Kind::kBool)), Kind::kBool);\n}\n\nTEST(Kind, IsTypeKind) {\n  EXPECT_TRUE(KindIsTypeKind(Kind::kBool));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kAny));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kDyn));\n}\n\nTEST(Kind, IsValueKind) {\n  EXPECT_TRUE(KindIsValueKind(Kind::kBool));\n  EXPECT_FALSE(KindIsValueKind(Kind::kAny));\n  EXPECT_FALSE(KindIsValueKind(Kind::kDyn));\n}\n\nTEST(Kind, Equality) {\n  EXPECT_EQ(Kind::kBool, TypeKind::kBool);\n  EXPECT_EQ(TypeKind::kBool, Kind::kBool);\n  EXPECT_EQ(Kind::kBool, ValueKind::kBool);\n  EXPECT_EQ(ValueKind::kBool, Kind::kBool);\n  EXPECT_NE(Kind::kBool, TypeKind::kInt);\n  EXPECT_NE(TypeKind::kInt, Kind::kBool);\n  EXPECT_NE(Kind::kBool, ValueKind::kInt);\n  EXPECT_NE(ValueKind::kInt, Kind::kBool);\n}\n\nTEST(TypeKind, ToString) {\n  EXPECT_EQ(TypeKindToString(TypeKind::kBool), KindToString(Kind::kBool));\n}\n\nTEST(ValueKind, ToString) {\n  EXPECT_EQ(ValueKindToString(ValueKind::kBool), KindToString(Kind::kBool));\n}\n}  \n}\n"
}
```
#### Prompt
```
from given json data give me json a data
1. Test Target: Array of a 'Code Line', which is exactly same as given "Code"
2. Test Object: Text. You should figure it out what it is testing and what is its object.
3. Input Data: Array of a 'Code Line', If there is input data for test target. Place here.
4. Exepected Output: Array of a 'Code Line', How EXPECT_EQ(), EXPECT_TRUE(), EXPECT_FALSE() or EXPECT_NE() should coverted.
 * when given "EXPECT_EQ(A, B)" should be  "%<< A;\\EXPECT_EQ(A, B)", B
 * when given "EXPECT_EQ(A, \"B\")" should be  "%<< A;\\EXPECT_EQ(A, B)", "B"
 * when given "EXPECT_TRUE(A)" should be "%<< (A)==true;\\EXPECT_TRUE(A)","true"
 * when given "EXPECT_FALSE(A)" should be "%<< (A)==false;\\EXPECT_FALSE(A)", "true"
 * when given "EXPECT_NE(A, B)" should be "%<< (A)!=(B);\\EXPECT_NE(A, B)", "true"
 * So, "EXPECT_EQ(A, B);\nEXPECT_TRUE(A);\n" should be ["%<< A;\\EXPECT_EQ(A, B)", B, "%<< (A)==true;\\EXPECT_TRUE(A)","true"]
5. Clang-repl Test: Array of a 'Code Line', Clang-repl base whole test case. It should "Unit Test - (Ground Truth)" all includes, global variable setting and etc.
 * Add "// Global Setting" with all includes, global variable setting and etc for include and other outside of testcase.
 * Add "// Test case" add Input Data, Test Target Call and Exepected Output.
  * Each test case "TEST(test_name)" should be changed to two lines first Test Object and test case name."// Test Object: test object of test_name",  "// Test case: test_name"
  * Each EXPECT_XXX() verfication should be changed to one "Exepected Output" converted.
 Most of "Unit Test - (Ground Truth)" must remain in "Clang-repl Test" if not add with comment and reason why it is not added.
 * If not not be added or useless code. "canNOtCalled();" to "// Next function can not called: canNOtCalled(); or "useLessSatement();" to "// Next statemnet useless: useLessSatement();"
 * remove all name spaces "namespace aname {" to "/*namespace aname {*/ and if close parenthesis is namespace "}" to "/*}*/"
  
\\```json
{
  "ID": 0,
  "Language": "cpp",
  "Repository Name": "google/cel-cpp",
  "File Name": "kind",
  "File Path in Repository": "common/kind.cc",
  "File Path for Unit Test": "common/kind_test.cc",
  "Code": "#ifndef THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#define THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#include \"common/kind.h\"        \n#include \"common/type_kind.h\"   \n#include \"common/value_kind.h\"  \n#endif  \n#include \"common/kind.h\"\n#include \"absl/strings/string_view.h\"\nnamespace cel {\nabsl::string_view KindToString(Kind kind) {\n  switch (kind) {\n    case Kind::kNullType:\n      return \"null_type\";\n    case Kind::kDyn:\n      return \"dyn\";\n    case Kind::kAny:\n      return \"any\";\n    case Kind::kType:\n      return \"type\";\n    case Kind::kTypeParam:\n      return \"type_param\";\n    case Kind::kFunction:\n      return \"function\";\n    case Kind::kBool:\n      return \"bool\";\n    case Kind::kInt:\n      return \"int\";\n    case Kind::kUint:\n      return \"uint\";\n    case Kind::kDouble:\n      return \"double\";\n    case Kind::kString:\n      return \"string\";\n    case Kind::kBytes:\n      return \"bytes\";\n    case Kind::kDuration:\n      return \"duration\";\n    case Kind::kTimestamp:\n      return \"timestamp\";\n    case Kind::kList:\n      return \"list\";\n    case Kind::kMap:\n      return \"map\";\n    case Kind::kStruct:\n      return \"struct\";\n    case Kind::kUnknown:\n      return \"*unknown*\";\n    case Kind::kOpaque:\n      return \"*opaque*\";\n    case Kind::kBoolWrapper:\n      return \"google.protobuf.BoolValue\";\n    case Kind::kIntWrapper:\n      return \"google.protobuf.Int64Value\";\n    case Kind::kUintWrapper:\n      return \"google.protobuf.UInt64Value\";\n    case Kind::kDoubleWrapper:\n      return \"google.protobuf.DoubleValue\";\n    case Kind::kStringWrapper:\n      return \"google.protobuf.StringValue\";\n    case Kind::kBytesWrapper:\n      return \"google.protobuf.BytesValue\";\n    default:\n      return \"*error*\";\n  }\n}\n}",
  "Unit Test - (Ground Truth)": "#include \"common/kind.h\"\n#include <limits>\n#include <type_traits>\n#include \"common/type_kind.h\"\n#include \"common/value_kind.h\"\n#include \"internal/testing.h\"\n\nnamespace cel {\nnamespace {\nstatic_assert(\n  std::is_same_v<std::underlying_type_t<TypeKind>, std::underlying_type_t<ValueKind>>,\n  \"TypeKind and ValueKind must have the same underlying type\"\n);\n\nTEST(Kind, ToString) {\n  EXPECT_EQ(KindToString(Kind::kError), \"*error*\");\n  EXPECT_EQ(KindToString(Kind::kNullType), \"null_type\");\n  EXPECT_EQ(KindToString(Kind::kDyn), \"dyn\");\n  EXPECT_EQ(KindToString(Kind::kAny), \"any\");\n  EXPECT_EQ(KindToString(Kind::kType), \"type\");\n  EXPECT_EQ(KindToString(Kind::kBool), \"bool\");\n  EXPECT_EQ(KindToString(Kind::kInt), \"int\");\n  EXPECT_EQ(KindToString(Kind::kUint), \"uint\");\n  EXPECT_EQ(KindToString(Kind::kDouble), \"double\");\n  EXPECT_EQ(KindToString(Kind::kString), \"string\");\n  EXPECT_EQ(KindToString(Kind::kBytes), \"bytes\");\n  EXPECT_EQ(KindToString(Kind::kDuration), \"duration\");\n  EXPECT_EQ(KindToString(Kind::kTimestamp), \"timestamp\");\n  EXPECT_EQ(KindToString(Kind::kList), \"list\");\n  EXPECT_EQ(KindToString(Kind::kMap), \"map\");\n  EXPECT_EQ(KindToString(Kind::kStruct), \"struct\");\n  EXPECT_EQ(KindToString(Kind::kUnknown), \"*unknown*\");\n  EXPECT_EQ(KindToString(Kind::kOpaque), \"*opaque*\");\n  EXPECT_EQ(KindToString(Kind::kBoolWrapper), \"google.protobuf.BoolValue\");\n  EXPECT_EQ(KindToString(Kind::kIntWrapper), \"google.protobuf.Int64Value\");\n  EXPECT_EQ(KindToString(Kind::kUintWrapper), \"google.protobuf.UInt64Value\");\n  EXPECT_EQ(KindToString(Kind::kDoubleWrapper), \"google.protobuf.DoubleValue\");\n  EXPECT_EQ(KindToString(Kind::kStringWrapper), \"google.protobuf.StringValue\");\n  EXPECT_EQ(KindToString(Kind::kBytesWrapper), \"google.protobuf.BytesValue\");\n  EXPECT_EQ(KindToString(static_cast<Kind>(std::numeric_limits<int>::max())), \"*error*\");\n}\n\nTEST(Kind, TypeKindRoundtrip) {\n  EXPECT_EQ(TypeKindToKind(KindToTypeKind(Kind::kBool)), Kind::kBool);\n}\n\nTEST(Kind, ValueKindRoundtrip) {\n  EXPECT_EQ(ValueKindToKind(KindToValueKind(Kind::kBool)), Kind::kBool);\n}\n\nTEST(Kind, IsTypeKind) {\n  EXPECT_TRUE(KindIsTypeKind(Kind::kBool));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kAny));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kDyn));\n}\n\nTEST(Kind, IsValueKind) {\n  EXPECT_TRUE(KindIsValueKind(Kind::kBool));\n  EXPECT_FALSE(KindIsValueKind(Kind::kAny));\n  EXPECT_FALSE(KindIsValueKind(Kind::kDyn));\n}\n\nTEST(Kind, Equality) {\n  EXPECT_EQ(Kind::kBool, TypeKind::kBool);\n  EXPECT_EQ(TypeKind::kBool, Kind::kBool);\n  EXPECT_EQ(Kind::kBool, ValueKind::kBool);\n  EXPECT_EQ(ValueKind::kBool, Kind::kBool);\n  EXPECT_NE(Kind::kBool, TypeKind::kInt);\n  EXPECT_NE(TypeKind::kInt, Kind::kBool);\n  EXPECT_NE(Kind::kBool, ValueKind::kInt);\n  EXPECT_NE(ValueKind::kInt, Kind::kBool);\n}\n\nTEST(TypeKind, ToString) {\n  EXPECT_EQ(TypeKindToString(TypeKind::kBool), KindToString(Kind::kBool));\n}\n\nTEST(ValueKind, ToString) {\n  EXPECT_EQ(ValueKindToString(ValueKind::kBool), KindToString(Kind::kBool));\n}\n}  \n}\n"
}
\\```
```
#### refined data

### Elfsong/Mercury 
solutions => Test Target
pretty_content =Refine=> Target Object
#### raw data
```json
{
  "slug_name": "reverse-only-letters",
  "meta_info": {
    "data": {
      "question": {
        "categoryTitle": "Algorithms",
        "content": "<p>Given a string <code>s</code>, reverse the string according to the following rules:</p>\n\n<ul>\n\t<li>All the characters that are not English letters remain in the same position.</li>\n\t<li>All the English letters (lowercase or uppercase) should be reversed.</li>\n</ul>\n\n<p>Return <code>s</code><em> after reversing it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"ab-cd\"\n<strong>Output:</strong> \"dc-ba\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a-bC-dEf-ghIj\"\n<strong>Output:</strong> \"j-Ih-gfE-dCba\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"Test1ng-Leet=code-Q!\"\n<strong>Output:</strong> \"Qedo1ct-eeLg=ntse-T!\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> consists of characters with ASCII values in the range <code>[33, 122]</code>.</li>\n\t<li><code>s</code> does not contain <code>'\\\"'</code> or <code>'\\\\'</code>.</li>\n</ul>"
      }
    }
  },
  "id": "917",
  "difficulty": "Easy",
  "pretty_content": [
    "Given a string s, reverse the string according to the following rules:\n\n\tAll the characters that are not English letters remain in the same position.\n\tAll the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.\n\n \nExample 1:\nInput: s = \"ab-cd\"\nOutput: \"dc-ba\"\nExample 2:\nInput: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"\nExample 3:\nInput: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\"\n\n \nConstraints:\n\n\t1 <= s.length <= 100\n\ts consists of characters with ASCII values in the range [33, 122].\n\ts does not contain '\"' or '\\\\'."
  ],
  "solutions": [
    {
      "hash": -3670788906086736251,
      "runtime": "14ms",
      "solution": "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        reversedLetters = list(filter(lambda x: x.isalpha(), s))\n        s = list(s)\n        for i in range(len(s)):\n            if s[i].isalpha():\n                s[i] = reversedLetters.pop()\n        return ''.join(s)"
    },
    {
      "hash": 8349588531444978383,
      "runtime": "3ms",
      "solution": "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        letters = [c for c in s if c.isalpha()]\n        \n        ans = []\n        for c in s:\n            if c.isalpha():\n                ans.append(letters.pop())\n            else:\n                ans.append(c)\n        return \"\".join(ans)"
    },
    {
      "hash": -6350836452767134536,
      "runtime": "15ms",
      "solution": "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i].isalpha() and s[j].isalpha():\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            else:\n                if s[i].isalpha():\n                    j -= 1\n                else:\n                    i += 1\n        return ''.join(s)"
    }
  ],
  "prompt": "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n",
  "generator_code": "None",
  "convert_online": "None",
  "convert_offline": "None",
  "evaluate_offline": "None",
  "entry_point": "None",
  "test_cases": "None"
}
```
#### Convert file



## Raw format
### Nutanix/CPP-UNITTEST-BENCH 
```
dataset:
  Split: train
  Column Names: ['ID', 'Language', 'Repository Name', 'File Name', 'File Path in Repository', 'File Path for Unit Test', 'Code', 'Unit Test - (Ground Truth)']
  First record: {'ID': 0, 'Language': 'cpp', 'Repository Name': 'google/cel-cpp', 'File Name': 'kind', 'File Path in Repository': 'common/kind.cc', 'File Path for Unit Test': 'common/kind_test.cc', 
  {
  'Code': '#ifndef THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#define THIRD_PARTY_CEL_CPP_BASE_KIND_H_\n#include "common/kind.h"        \n#include "common/type_kind.h"   \n#include "common/value_kind.h"  \n#endif  \n#include "common/kind.h"\n#include "absl/strings/string_view.h"\nnamespace cel {\nabsl::string_view KindToString(Kind kind) {\n  switch (kind) {\n    case Kind::kNullType:\n      return "null_type";\n    case Kind::kDyn:\n      return "dyn";\n    case Kind::kAny:\n      return "any";\n    case Kind::kType:\n      return "type";\n    case Kind::kTypeParam:\n      return "type_param";\n    case Kind::kFunction:\n      return "function";\n    case Kind::kBool:\n      return "bool";\n    case Kind::kInt:\n      return "int";\n    case Kind::kUint:\n      return "uint";\n    case Kind::kDouble:\n      return "double";\n    case Kind::kString:\n      return "string";\n    case Kind::kBytes:\n      return "bytes";\n    case Kind::kDuration:\n      return "duration";\n    case Kind::kTimestamp:\n      return "timestamp";\n    case Kind::kList:\n      return "list";\n    case Kind::kMap:\n      return "map";\n    case Kind::kStruct:\n      return "struct";\n    case Kind::kUnknown:\n      return "*unknown*";\n    case Kind::kOpaque:\n      return "*opaque*";\n    case Kind::kBoolWrapper:\n      return "google.protobuf.BoolValue";\n    case Kind::kIntWrapper:\n      return "google.protobuf.Int64Value";\n    case Kind::kUintWrapper:\n      return "google.protobuf.UInt64Value";\n    case Kind::kDoubleWrapper:\n      return "google.protobuf.DoubleValue";\n    case Kind::kStringWrapper:\n      return "google.protobuf.StringValue";\n    case Kind::kBytesWrapper:\n      return "google.protobuf.BytesValue";\n    default:\n      return "*error*";\n  }\n}\n}  ', 
  'Unit Test - (Ground Truth)': '#include "common/kind.h"\n#include <limits>\n#include <type_traits>\n#include "common/type_kind.h"\n#include "common/value_kind.h"\n#include "internal/testing.h"\nnamespace cel {\nnamespace {\nstatic_assert(std::is_same_v<std::underlying_type_t<TypeKind>,\n                             std::underlying_type_t<ValueKind>>,\n              "TypeKind and ValueKind must have the same underlying type");\nTEST(Kind, ToString) {\n  EXPECT_EQ(KindToString(Kind::kError), "*error*");\n  EXPECT_EQ(KindToString(Kind::kNullType), "null_type");\n  EXPECT_EQ(KindToString(Kind::kDyn), "dyn");\n  EXPECT_EQ(KindToString(Kind::kAny), "any");\n  EXPECT_EQ(KindToString(Kind::kType), "type");\n  EXPECT_EQ(KindToString(Kind::kBool), "bool");\n  EXPECT_EQ(KindToString(Kind::kInt), "int");\n  EXPECT_EQ(KindToString(Kind::kUint), "uint");\n  EXPECT_EQ(KindToString(Kind::kDouble), "double");\n  EXPECT_EQ(KindToString(Kind::kString), "string");\n  EXPECT_EQ(KindToString(Kind::kBytes), "bytes");\n  EXPECT_EQ(KindToString(Kind::kDuration), "duration");\n  EXPECT_EQ(KindToString(Kind::kTimestamp), "timestamp");\n  EXPECT_EQ(KindToString(Kind::kList), "list");\n  EXPECT_EQ(KindToString(Kind::kMap), "map");\n  EXPECT_EQ(KindToString(Kind::kStruct), "struct");\n  EXPECT_EQ(KindToString(Kind::kUnknown), "*unknown*");\n  EXPECT_EQ(KindToString(Kind::kOpaque), "*opaque*");\n  EXPECT_EQ(KindToString(Kind::kBoolWrapper), "google.protobuf.BoolValue");\n  EXPECT_EQ(KindToString(Kind::kIntWrapper), "google.protobuf.Int64Value");\n  EXPECT_EQ(KindToString(Kind::kUintWrapper), "google.protobuf.UInt64Value");\n  EXPECT_EQ(KindToString(Kind::kDoubleWrapper), "google.protobuf.DoubleValue");\n  EXPECT_EQ(KindToString(Kind::kStringWrapper), "google.protobuf.StringValue");\n  EXPECT_EQ(KindToString(Kind::kBytesWrapper), "google.protobuf.BytesValue");\n  EXPECT_EQ(KindToString(static_cast<Kind>(std::numeric_limits<int>::max())),\n            "*error*");\n}\nTEST(Kind, TypeKindRoundtrip) {\n  EXPECT_EQ(TypeKindToKind(KindToTypeKind(Kind::kBool)), Kind::kBool);\n}\nTEST(Kind, ValueKindRoundtrip) {\n  EXPECT_EQ(ValueKindToKind(KindToValueKind(Kind::kBool)), Kind::kBool);\n}\nTEST(Kind, IsTypeKind) {\n  EXPECT_TRUE(KindIsTypeKind(Kind::kBool));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kAny));\n  EXPECT_TRUE(KindIsTypeKind(Kind::kDyn));\n}\nTEST(Kind, IsValueKind) {\n  EXPECT_TRUE(KindIsValueKind(Kind::kBool));\n  EXPECT_FALSE(KindIsValueKind(Kind::kAny));\n  EXPECT_FALSE(KindIsValueKind(Kind::kDyn));\n}\nTEST(Kind, Equality) {\n  EXPECT_EQ(Kind::kBool, TypeKind::kBool);\n  EXPECT_EQ(TypeKind::kBool, Kind::kBool);\n  EXPECT_EQ(Kind::kBool, ValueKind::kBool);\n  EXPECT_EQ(ValueKind::kBool, Kind::kBool);\n  EXPECT_NE(Kind::kBool, TypeKind::kInt);\n  EXPECT_NE(TypeKind::kInt, Kind::kBool);\n  EXPECT_NE(Kind::kBool, ValueKind::kInt);\n  EXPECT_NE(ValueKind::kInt, Kind::kBool);\n}\nTEST(TypeKind, ToString) {\n  EXPECT_EQ(TypeKindToString(TypeKind::kBool), KindToString(Kind::kBool));\n}\nTEST(ValueKind, ToString) {\n  EXPECT_EQ(ValueKindToString(ValueKind::kBool), KindToString(Kind::kBool));\n}\n}  \n}  '}
  }
  -----
```
### Elfsong/Mercury
```
dataset:
  Split: train
  Column Names: ['slug_name', 'meta_info', 'id', 'difficulty', 'pretty_content', 'solutions', 'prompt', 'generator_code', 'convert_online', 'convert_offline', 'evaluate_offline', 'entry_point', 'test_cases']
  First record: {'slug_name': 'reverse-only-letters', 'meta_info': {'data': {'question': {'categoryTitle': 'Algorithms', 'content': '<p>Given a string <code>s</code>, reverse the string according to the following rules:</p>\n\n<ul>\n\t<li>All the characters that are not English letters remain in the same position.</li>\n\t<li>All the English letters (lowercase or uppercase) should be reversed.</li>\n</ul>\n\n<p>Return <code>s</code><em> after reversing it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class="example">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = "ab-cd"\n<strong>Output:</strong> "dc-ba"\n</pre><p><strong class="example">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = "a-bC-dEf-ghIj"\n<strong>Output:</strong> "j-Ih-gfE-dCba"\n</pre><p><strong class="example">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = "Test1ng-Leet=code-Q!"\n<strong>Output:</strong> "Qedo1ct-eeLg=ntse-T!"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of characters with ASCII values in the range <code>[33, 122]</code>.</li>\n\t<li><code>s</code> does not contain <code>&#39;\\&quot;&#39;</code> or <code>&#39;\\\\&#39;</code>.</li>\n</ul>\n', 'difficulty': 'Easy', 'questionFrontendId': '917', 'questionId': '953', 'questionTitle': 'Reverse Only Letters', 'questionTitleSlug': 'reverse-only-letters', 'similarQuestions': '[{"title": "Faulty Keyboard", "titleSlug": "faulty-keyboard", "difficulty": "Easy", "translatedTitle": null}]', 'stats': '{"totalAccepted": "192.6K", "totalSubmission": "302.8K", "totalAcceptedRaw": 192555, "totalSubmissionRaw": 302796, "acRate": "63.6%"}', 'topicTags': [{'name': 'Two Pointers', 'slug': 'two-pointers'}, {'name': 'String', 'slug': 'string'}]}}}, 'id': '917', 'difficulty': 'Easy', 'pretty_content': ['Given a string s, reverse the string according to the following rules:\n\n\n\tAll the characters that are not English letters remain in the same position.\n\tAll the English letters (lowercase or uppercase) should be reversed.\n\n\nReturn s after reversing it.\n\n\xa0\nExample 1:\nInput: s = "ab-cd"\nOutput: "dc-ba"\nExample 2:\nInput: s = "a-bC-dEf-ghIj"\nOutput: "j-Ih-gfE-dCba"\nExample 3:\nInput: s = "Test1ng-Leet=code-Q!"\nOutput: "Qedo1ct-eeLg=ntse-T!"\n\n\xa0\nConstraints:\n\n\n\t1 <= s.length <= 100\n\ts consists of characters with ASCII values in the range [33, 122].\n\ts does not contain \'\\"\' or \'\\\\\'.\n\n\n'], 'solutions': [{'hash': -3670788906086736251, 'runtime': '14ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        reversedLetters = list(filter(lambda x: x.isalpha(),s))\n        s = list(s)\n        for i in range(len(s)):\n            if s[i].isalpha():\n                s[i] = reversedLetters.pop()\n        return \'\'.join(s)'}, {'hash': 8349588531444978383, 'runtime': '3ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        letters = [c for c in s if c.isalpha()]\n        \n        ans = []\n        for c in s:\n            if c.isalpha():\n                ans.append(letters.pop())\n                \n            else:\n                ans.append(c)\n                \n        return "".join(ans)\n        \n        '}, {'hash': -6350836452767134536, 'runtime': '15ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        \n        # s = list(s)\n        # res = []\n\n        # for i in s:\n        #     if i.isalpha():\n        #         res.append(str(i))\n        # res.reverse()\n        # j=0\n        # for i in range(len(s)):\n        #     if s[i].isalpha():\n        #         s[i] = res[j]\n        #         j+=1\n        # return \'\'.join(s)\n        s = list(s)\n        i=0;j=len(s)-1\n        while(i<j):\n            if s[i].isalpha() and s[j].isalpha():\n                temp = s[i]\n                s[i] =s[j]\n                s[j] = temp\n                i+=1\n                j-=1\n            else:\n                if s[i].isalpha():\n                    j-=1\n                else:\n                    i+=1\n        return \'\'.join(s)'}, {'hash': 8016538064399867409, 'runtime': '16ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        word = list(s)\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            if not word[left].isalpha():\n                left += 1\n            elif not word[right].isalpha():\n                right -= 1\n            else:\n                temp = word[right]\n                word[right] = word[left]\n                word[left] = temp\n                left += 1\n                right -= 1\n        return "".join(word)\n        '}, {'hash': 2872889419129109904, 'runtime': '17ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        l=[]\n        s=list(s)\n        i=0\n        j=len(s)-1\n        v="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"\n        while(i<j):\n            if s[i]in v and s[j] in v:\n                s[i],s[j]=s[j],s[i]\n                i+=1\n                j-=1\n            elif(s[i]in v):\n                j-=1\n            elif(s[j] in v):\n                i+=1\n            else:\n                i+=1\n                j-=1\n        return "".join(s)\n        '}, {'hash': -4908537881192473183, 'runtime': '21ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        nonascii_chars = "".join([x if ord(x) < 65 or ord(x) > 122 or (ord(x) <= 96 and ord(x) >= 91) else \'hardybardy\' for x in list(s)])\n        ascii_chars = [x for x in list(s) if ord(x) >= 65 and ord(x) <= 122 and not (ord(x) <= 96 and ord(x) >= 91)]\n        num_ascii = len(ascii_chars)\n        for i in range(num_ascii):\n            idx = num_ascii - i - 1\n            nonascii_chars = nonascii_chars.replace(\'hardybardy\',ascii_chars[idx],1)\n        return nonascii_chars'}, {'hash': -7841058742707738323, 'runtime': '8ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        if len(s) == 1:\n            return s\n        left = 0\n        right = len(s) - 1\n        s = list(s)\n        while left < right:\n            while left < right and not s[left].isalpha():\n                left += 1\n            while left < right and not s[right].isalpha():\n                right -= 1\n            temp = s[left]\n            s[left] = s[right]\n            s[right] = temp\n            left += 1\n            right -= 1\n        return ("".join(s))'}, {'hash': -1729136929612821686, 'runtime': '20ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if not s[i].isalpha():\n                i += 1\n            elif not s[j].isalpha():\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return "".join(s)'}, {'hash': 8307912473383236898, 'runtime': '9ms', 'solution': "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        u=s[::-1]\n        l=[]\n        for i in range(len(u)):\n            if u[i].isalpha():\n                l.append(u[i])\n        for i in range(len(s)):\n            if not s[i].isalpha():\n                l.insert(i,s[i])\n        p=''.join(l)\n        return p\n        "}, {'hash': 424141933951399095, 'runtime': '13ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        reversedLetters = list(filter(lambda x: x.isalpha(),s))\n        s = list(s)\n        for i in range(len(s)):\n            if s[i].isalpha():\n                print(s[i])\n                s[i] = reversedLetters.pop()\n        return \'\'.join(s)'}, {'hash': 6853605583422190730, 'runtime': '12ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        ans = list(s)\n        n = len(ans)\n        left = 0\n        right = n-1\n        while left < right:\n            if ans[left].isalpha() and ans[right].isalpha():\n                temp = ans[left]\n                ans[left] = ans[right]\n                ans[right] = temp\n                left += 1\n                right -= 1\n            else:\n                if not ans[left].isalpha():\n                    left += 1\n                if not ans[right].isalpha():\n                    right -= 1\n        return \'\'.join(ans)\n'}, {'hash': 9179398740204144297, 'runtime': '4ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n\n        letters = []\n        ans = []\n\n        for letter in s:\n            if letter.isalpha():\n                letters.append(letter)\n        \n        for c in s:\n            if c.isalpha():\n                ans.append(letters.pop())\n            \n            else:\n                ans.append(c)\n        \n        return "".join(ans)\n\n\n\n\n            \n\n            \n        \n\n\n        '}, {'hash': 4084103629727521854, 'runtime': '19ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        \n        s = list(s)\n        res = []\n\n        for i in s:\n            if i.isalpha():\n                res.append(str(i))\n        res.reverse()\n        j=0\n        for i in range(len(s)):\n            if s[i].isalpha():\n                s[i] = res[j]\n                j+=1\n        return \'\'.join(s)'}, {'hash': 3709167620302738103, 'runtime': '10ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        strn=[]\n        l=[]\n        for i in range(len(s)):\n            if s[i].isalpha():\n                strn.append(s[i])\n                \n        strn.reverse()\n        j=0\n        for i in s:\n            if i.isalpha():\n                l.append(strn[j])\n                j+=1\n            else:\n                l.append(i)\n\n        return "".join(l)\n        '}, {'hash': 5482033498018817236, 'runtime': '6ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        S = list(s)\n        c = [x for x in s if x.isalpha()]\n        for i in range(len(S)):\n            if S[i].isalpha():\n                S[i] = c.pop()\n        return "".join(S)\n        '}, {'hash': -1120787364339832189, 'runtime': '11ms', 'solution': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        s=list(s)\n        l=0\n        h=len(s)-1\n        vowel=[\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\', \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\', \'M\', \'N\', \'O\', \'P\', \'Q\', \'R\', \'S\', \'T\', \'U\', \'V\', \'W\', \'X\', \'Y\', \'Z\']\n        while(h>l):\n            if (s[l] in vowel and s[h] in vowel):\n                s[l],s[h]=s[h],s[l]\n                l=l+1\n                h=h-1\n            if(s[l] not in vowel):\n                l=l+1\n            if(s[h] not in vowel):\n                h=h-1\n        return \'\'.join(s)'}], 'prompt': 'class Solution(object):\n    def reverseOnlyLetters(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        \n', 'generator_code': 'None', 'convert_online': 'None', 'convert_offline': 'None', 'evaluate_offline': 'None', 'entry_point': 'None', 'test_cases': 'None'}
  -----
  Split: eval
  Column Names: ['slug_name', 'meta_info', 'id', 'difficulty', 'pretty_content', 'solutions', 'prompt', 'generator_code', 'convert_online', 'convert_offline', 'evaluate_offline', 'entry_point', 'test_cases']
  First record: {'slug_name': 'spiral-matrix', 'meta_info': {'data': {'question': {'categoryTitle': 'Algorithms', 'content': '<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class="example">Example 1:</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class="example">Example 2:</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n', 'difficulty': 'Medium', 'questionFrontendId': '54', 'questionId': '54', 'questionTitle': 'Spiral Matrix', 'questionTitleSlug': 'spiral-matrix', 'similarQuestions': '[{"title": "Spiral Matrix II", "titleSlug": "spiral-matrix-ii", "difficulty": "Medium", "translatedTitle": null}, {"title": "Spiral Matrix III", "titleSlug": "spiral-matrix-iii", "difficulty": "Medium", "translatedTitle": null}, {"title": "Spiral Matrix IV", "titleSlug": "spiral-matrix-iv", "difficulty": "Medium", "translatedTitle": null}]', 'stats': '{"totalAccepted": "1.3M", "totalSubmission": "2.6M", "totalAcceptedRaw": 1260175, "totalSubmissionRaw": 2618561, "acRate": "48.1%"}', 'topicTags': [{'name': 'Array', 'slug': 'array'}, {'name': 'Matrix', 'slug': 'matrix'}, {'name': 'Simulation', 'slug': 'simulation'}]}}}, 'id': '54', 'difficulty': 'Medium', 'pretty_content': ['Given an m x n matrix, return all elements of the matrix in spiral order.\n\n\xa0\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\xa0\nConstraints:\n\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 10\n\t-100 <= matrix[i][j] <= 100\n\n\n'], 'solutions': [{'hash': -7901417908281767226, 'runtime': '44ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n        top = left = 0\n        bottom = len(matrix)-1\n        right = len(matrix[0])-1\n        ans = []\n        while left<=right and top<=bottom:\n\n            for i in range(left,right+1):\n                ans.append(matrix[top][i])\n\n            top +=1\n\n            for i in range(top,bottom+1):\n                ans.append(matrix[i][right])\n\n            right-=1\n\n            if top<= bottom:\n\n                for i in range(right,left-1,-1):\n                    ans.append(matrix[bottom][i])\n\n                bottom-=1\n\n            if left<=right:\n\n                for i in range(bottom,top-1,-1):\n                    ans.append(matrix[i][left])\n\n                left+=1\n\n        return ans'}, {'hash': 2979623801820750370, 'runtime': '36ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n\n        while left <= right and top <= bottom:\n            # Traverse top row\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n\n            # Traverse right column\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n\n            # Traverse bottom row\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n\n            # Traverse left column\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n\n        return result'}, {'hash': 5830702755919632550, 'runtime': '24ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom, left, right = 0, rows-1, 0, cols-1\n        result = []\n        \n        while len(result) < rows * cols:\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        \n        return result'}, {'hash': 6143528053069974267, 'runtime': '56ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result = []\n        while matrix:\n            result += (matrix.pop(0))\n            if matrix and matrix[0]:\n                result += ([row.pop() for row in matrix])\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                result += ([row.pop(0) for row in matrix][::-1])\n        return result'}, {'hash': -6407230161003952030, 'runtime': '60ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            matrix = (list(zip(*matrix)))[::-1]\n        return result'}, {'hash': 471172117717305173, 'runtime': '68ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left,right = 0, len(matrix[0])\n        top , bottom = 0,len(matrix)\n        while left < right and top < bottom:\n            #from left to right\n            for a in range(left, right):\n                res.append(matrix[top][a])\n            top +=1\n            \n            #from top to bottom \n            for a in range(top , bottom):\n                res.append(matrix[a][right-1])\n            right -=1\n            \n            #break loop if we dont have left to right\n            if not (left < right and top < bottom):\n                break\n            \n            #from right to left\n            for a in range(right-1 , left-1 , -1):\n                res.append(matrix[bottom-1][a])\n            bottom -=1\n            # break\n            \n            #from bottom to up \n            for a in range(bottom-1, top-1, -1):\n                res.append(matrix[a][left])\n            left +=1\n        \n        return res'}, {'hash': -4981930739436859778, 'runtime': '20ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        first_row = 0\n        last_row = len(matrix) - 1\n        first_col = 0\n        last_col = len(matrix[0]) - 1\n\n        output = []\n\n        while True:  # Revisit\n            # top\n            output.extend(matrix[first_row][first_col:last_col + 1])\n            first_row += 1\n\n            if first_row > last_row:\n                break\n\n            # right\n            for i in range(first_row, last_row + 1):\n                output.append(matrix[i][last_col])\n            last_col -= 1\n\n            if first_col > last_col:\n                break\n\n            # bottom\n            output.extend([matrix[last_row][j] for j in range(last_col, first_col-1, -1)])\n            last_row -= 1\n\n            if first_row > last_row:\n                break\n\n            # left\n            for k in range(last_row, first_row - 1, -1):\n                output.append(matrix[k][first_col])\n            first_col += 1\n\n            if first_col > last_col:\n                break\n\n        return output'}, {'hash': -4488399605146645399, 'runtime': '52ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        row , col = len(matrix), len(matrix[0])\n        u, d, l, r = 0, row-1, 0, col-1\n        ans = []\n        while len(ans) < (row*col):\n            for i in range(l, r+1):\n                ans.append(matrix[u][i])\n            u += 1\n\n            for i in range(u, d+1):\n                ans.append(matrix[i][r])\n            r -= 1\n\n            if u <= d:\n                for i in range(r, l-1, -1):\n                    ans.append(matrix[d][i])\n                d -= 1\n            if l <= r:\n                for i in range(d, u-1, -1): \n                    ans.append(matrix[i][l])\n                l+=1\n        return ans'}, {'hash': -7303749964658191738, 'runtime': '64ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ans = []\n        # boundaries\n        left, right = 0, len(matrix[0])-1\n        top, bottom = 0, len(matrix)-1\n\n        while left <= right and top <= bottom:\n            # right\n            for c in range(left, right+1):\n                ans.append(matrix[top][c])\n            top += 1\n            \n            # down\n            for r in range(top, bottom+1):\n                ans.append(matrix[r][right])\n            right -= 1\n\n            if not (left <= right and top <= bottom):\n                break\n\n            # left\n            for c in range(right, left-1, -1):\n                ans.append(matrix[bottom][c])\n            bottom -= 1\n\n            # up\n            for r in range(bottom, top-1, -1):\n                ans.append(matrix[r][left])\n            left += 1\n\n        return ans'}, {'hash': 2531128780300420629, 'runtime': '28ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result =[]\n        if len(matrix) ==1:\n            return matrix[0]\n        if len(matrix)==0:\n            return []\n        result += matrix.pop(0)\n        print(result)\n        if len(matrix)!=0 and len(matrix[0])!=0:\n            for row in range(len(matrix)):\n                result.append(matrix[row].pop(-1))\n        print (result)\n        if len(matrix)!=0 and len(matrix[-1])!=0:\n            a=matrix.pop(-1)\n            a.reverse()\n            result +=a\n        print(result)\n        print(matrix)\n        if len(matrix)!=0 and len(matrix[0])!=0:\n            col1 = []\n            for row in range (len(matrix)):\n                col1.append(matrix[row].pop(0))\n            col1.reverse()\n            result+=col1\n        print(result)\n        print(matrix)\n        result+=self.spiralOrder(matrix)\n        print(result)\n        return result\n        '}, {'hash': 1625463847752106776, 'runtime': '48ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ans = []\n\n        leftToRightStartIndex = 0\n        leftToRightEndIndex = len(matrix[0])\n\n        upToDownStartIndex = 0\n        upToDownEndIndex = len(matrix)\n\n        rightToLeftStartIndex = len(matrix[0]) - 1\n        rightToLeftEndIndex = 0\n\n        downToUpStartIndex = len(matrix) - 1\n        downToUpEndIndex = 1\n\n        while leftToRightStartIndex <= rightToLeftStartIndex and upToDownStartIndex <= downToUpStartIndex:\n            for iterator in range(leftToRightStartIndex, leftToRightEndIndex):\n                ans.append(matrix[upToDownStartIndex][iterator])\n\n            for iterator in range(upToDownStartIndex + 1, upToDownEndIndex):\n                ans.append(matrix[iterator][rightToLeftStartIndex])\n\n            if upToDownStartIndex < downToUpStartIndex:\n                for iterator in range(rightToLeftStartIndex - 1, rightToLeftEndIndex - 1, -1):\n                    ans.append(matrix[downToUpStartIndex][iterator])\n\n            if leftToRightStartIndex < rightToLeftStartIndex:\n                for iterator in range(downToUpStartIndex - 1, upToDownStartIndex, -1):\n                    ans.append(matrix[iterator][leftToRightStartIndex])\n\n            leftToRightStartIndex += 1\n            leftToRightEndIndex -= 1\n            upToDownStartIndex += 1\n            upToDownEndIndex -= 1\n            rightToLeftStartIndex -= 1\n            rightToLeftEndIndex += 1\n            downToUpStartIndex -= 1\n            downToUpEndIndex += 1\n\n        return ans\n\n\n\n\n\n\n            \n\n\n        '}, {'hash': 1359650924783587915, 'runtime': '40ms', 'solution': "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        row_t, row_b, col_l, col_r = 0, m-1, 0, n-1\n        res = []\n\n        while row_t <= row_b and col_l <= col_r:\n            # Go through top row\n            for j in range(col_l, col_r + 1):\n                res.append(matrix[row_t][j])\n\n            # Go through last col, starting at 2nd to first row\n            for i in range(row_t + 1, row_b + 1):\n                res.append(matrix[i][col_r])\n\n            # Go through last row, starting at 2nd to last col\n            if row_t != row_b: # If row_t == row_b, we've already gone through the last row since it's also the first row\n                for j in range(col_r - 1, col_l - 1, -1):\n                    res.append(matrix[row_b][j])\n\n            # Go through first col, starting at 2nd to last row up to the 2nd to first row\n            if col_l != col_r: # If col_l == col_r, we've already gone through the first col since it's also the last col\n                for i in range(row_b - 1, row_t, -1):\n                    res.append(matrix[i][col_l])\n\n            row_t, row_b, col_l, col_r = row_t + 1, row_b - 1, col_l + 1, col_r - 1\n\n        return res\n\n# Time Complexity: O(mn)        Go through all elements\n# Space Complexity: O(mn)       Will store all elements in res array"}, {'hash': -5179929568505095957, 'runtime': '32ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        res = []\n        for o in range(0, min(m, n) // 2 + 1):\n            left = o\n            right = n- o - 1\n            up = o\n            down = m - o - 1\n            print(left, right, up, down)\n            if down < up or right < left:\n                continue\n            #if up == down and left == right:\n            #    res.append(matrix[up][left])\n            #    continue\n            for j in range(left, right):\n                res.append(matrix[up][j])\n            if up == down:\n                res.append(matrix[up][right])\n                continue\n            for i in range(up, down):\n                res.append(matrix[i][right])\n            if left == right:\n                res.append(matrix[down][right])\n                continue\n            for j in range(right, left, -1):\n                res.append(matrix[down][j])\n            for i in range(down, up, -1):\n                res.append(matrix[i][left])\n        return res'}, {'hash': -5842837003432617729, 'runtime': '14ms', 'solution': 'class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        xmin = -1\n        xmax = len(matrix)\n        ymin = -1\n        ymax = len(matrix[0])\n        x = y = 0\n        res = [matrix[0][0]]\n\n        while xmin <= xmax and ymin <= ymax:\n            for i, direction in enumerate([[0,1],[1,0],[0,-1],[-1,0]]):\n                while xmin < x + direction[0] < xmax and ymin < y + direction[1] < ymax:\n                    x += direction[0]\n                    y += direction[1]\n                    res.append(matrix[x][y])\n                if i == 0:\n                    xmin += 1\n                elif i == 1:\n                    ymax -= 1\n                elif i == 2:\n                    xmax -= 1\n                elif i == 3:\n                    ymin += 1\n                if xmin + 1 == xmax or ymin + 1 == ymax:\n                    break\n        return res'}], 'prompt': 'class Solution(object):\n    def spiralOrder(self, matrix):\n        """\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        """\n        \n', 'generator_code': 'import random\n\ndef generate_test_case():\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    return [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]', 'convert_online': 'def convert_online(case):\n    return case', 'convert_offline': 'def convert_offline(case):\n    return case', 'evaluate_offline': 'def evaluate_offline(inputs, outputs, expected):\n    if outputs == expected:\n        return True\n    \n    return False', 'entry_point': 'spiralOrder', 'test_cases': '[{"input": [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], "expected": [1, 2, 3, 6, 9, 8, 7, 4, 5]}, {"input": [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]], "expected": [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]}, {"input": [[[37, 48, 94, 7], [33, 94, -38, 97], [79, -96, -77, 93], [52, 77, 72, -23], [-24, 72, -45, -74], [2, 37, 4, -89], [5, 60, 61, 44], [-24, 52, 19, 1], [-1, -50, 33, 57], [-58, -56, 15, -13]]], "expected": [37, 48, 94, 7, 97, 93, -23, -74, -89, 44, 1, 57, -13, 15, -56, -58, -1, -24, 5, 2, -24, 52, 79, 33, 94, -38, -77, 72, -45, 4, 61, 19, 33, -50, 52, 60, 37, 72, 77, -96]}, {"input": [[[29, -85, -35, 22, -41, 58, -13, -5, 31], [-15, -77, 24, 100, 26, -85, -60, -79, -23], [-20, -94, -24, -96, 37, -22, 92, -93, 67], [36, -36, -31, -90, 41, -70, 56, 8, 60], [66, 12, 53, -88, 40, 43, 91, 70, 33], [2, -98, -16, -18, -28, 89, -68, -53, 20], [87, 15, -54, -99, 13, -62, -85, 82, 57], [-39, -35, 51, 0, -95, -29, -49, -38, -100], [-89, 87, 55, -67, -6, -38, 65, -20, -69]]], "expected": [29, -85, -35, 22, -41, 58, -13, -5, 31, -23, 67, 60, 33, 20, 57, -100, -69, -20, 65, -38, -6, -67, 55, 87, -89, -39, 87, 2, 66, 36, -20, -15, -77, 24, 100, 26, -85, -60, -79, -93, 8, 70, -53, 82, -38, -49, -29, -95, 0, 51, -35, 15, -98, 12, -36, -94, -24, -96, 37, -22, 92, 56, 91, -68, -85, -62, 13, -99, -54, -16, 53, -31, -90, 41, -70, 43, 89, -28, -18, -88, 40]}, {"input": [[[60, 61, 48, -97, -96, -25], [-89, -13, 45, 5, -88, -71], [-31, -23, 11, -22, 82, -27], [-90, -82, -27, -86, -99, -10], [58, -54, 66, 63, 100, 8], [100, 76, -20, 0, -50, 93], [-16, -57, 33, -15, 95, 100]]], "expected": [60, 61, 48, -97, -96, -25, -71, -27, -10, 8, 93, 100, 95, -15, 33, -57, -16, 100, 58, -90, -31, -89, -13, 45, 5, -88, 82, -99, 100, -50, 0, -20, 76, -54, -82, -23, 11, -22, -86, 63, 66, -27]}, {"input": [[[-14, -12, 26, 65, -89, 86, 18, 18, -82, -28], [-47, -42, -79, -10, 34, 70, -85, -16, 95, -6], [28, -84, 10, 98, 30, 56, -76, -52, -22, 47]]], "expected": [-14, -12, 26, 65, -89, 86, 18, 18, -82, -28, -6, 47, -22, -52, -76, 56, 30, 98, 10, -84, 28, -47, -42, -79, -10, 34, 70, -85, -16, 95]}, {"input": [[[39, 92, 43, 74, -77, -64], [3, -76, -24, 94, 93, 65], [-70, -81, -11, 52, -34, 61], [-98, 83, 79, 92, 31, -99]]], "expected": [39, 92, 43, 74, -77, -64, 65, 61, -99, 31, 92, 79, 83, -98, -70, 3, -76, -24, 94, 93, -34, 52, -11, -81]}]'}
  -----
```
